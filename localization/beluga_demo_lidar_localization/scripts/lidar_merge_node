#!/usr/bin/env python3

# Copyright 2025 Ekumen, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import rclpy
from rclpy.node import Node
from std_msgs.msg import Header
from sensor_msgs.msg import LaserScan, PointCloud2
import laser_geometry.laser_geometry as lg
import message_filters
import tf2_ros
from tf2_sensor_msgs.tf2_sensor_msgs import do_transform_cloud
import sensor_msgs_py.point_cloud2 as pc2
import numpy as np


class LidarMergeNode(Node):
    def __init__(self):
        super().__init__('lidar_merge_node')
        self.projector = lg.LaserProjection()
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        self.target_frame = self.declare_parameter('target_frame', 'base_link').value

        self.scan1_sub = message_filters.Subscriber(self, LaserScan, 'scan1')
        self.scan2_sub = message_filters.Subscriber(self, LaserScan, 'scan2')

        slop_seconds = self.declare_parameter('slop_seconds', 0.1).value
        self.ts = message_filters.ApproximateTimeSynchronizer(
            [self.scan1_sub, self.scan2_sub], 10, slop_seconds)
        self.ts.registerCallback(self.scan_callback)

        self.cloud_pub = self.create_publisher(PointCloud2, 'cloud', 10)

    def scan_callback(self, scan1, scan2):
        try:
            cloud1 = self.projector.projectLaser(scan1)
            cloud2 = self.projector.projectLaser(scan2)

            transform1 = self.tf_buffer.lookup_transform(
                self.target_frame, scan1.header.frame_id, scan1.header.stamp)
            transformed_cloud1 = do_transform_cloud(cloud1, transform1)

            transform2 = self.tf_buffer.lookup_transform(
                self.target_frame, scan2.header.frame_id, scan2.header.stamp)
            transformed_cloud2 = do_transform_cloud(cloud2, transform2)

            points1 = pc2.read_points_numpy(transformed_cloud1, field_names=["x", "y", "z"])
            points2 = pc2.read_points_numpy(transformed_cloud2, field_names=["x", "y", "z"])

            merged_points = np.concatenate((points1, points2), axis=0)

            header = Header()
            header.stamp = scan1.header.stamp
            header.frame_id = self.target_frame
            merged_cloud = pc2.create_cloud_xyz32(header, merged_points)

            self.cloud_pub.publish(merged_cloud)

        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            self.get_logger().warn(f'Could not transform scans: {e}')

def main(args=None):
    rclpy.init(args=args)
    node = LidarMergeNode()
    try:
        rclpy.spin(node)
    finally:
        node.destroy_node()
        rclpy.try_shutdown()

if __name__ == '__main__':
    main()
